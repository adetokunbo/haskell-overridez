#!/usr/bin/env bash
set -euo pipefail

_HOZ_KNOWN_OPTS="doJailbreak dontCheck dontHaddock"
_HOZ_VERSION=0.9.2

haskell-overridez() {
    local first_arg=${1:-''}
    [[ ${first_arg} == "fetch" ]] && {
        shift
        _fetch_configs "$@"
        return 0
    }
    _manage_override_configs "$@"
}

_manage_override_configs() {
    OPTIND=1
    local working_dir=$(pwd)
    local just_show_usage=0
    local next_func=_save_cabal2nix
    local opt
    while getopts ":vigdlho:" opt;
    do
        case $opt in
            o)
                working_dir=$OPTARG
                ;;
            h)
                just_show_usage=1
                ;;
            d)
                next_func=_delete_if_present
                ;;
            g)
                next_func=_save_github_json
                ;;
            i)
                next_func=_init_project
                ;;
            l)
                next_func=_list_overrides
                ;;
            v)
                next_func=_show_version
                ;;
            \?)
                >&2 echo "Invalid option: -$OPTARG"
                >&2 echo
                >&2 _show_usage_manage_override
                return 1
                ;;
        esac
    done
    shift $((OPTIND-1))

    (( $just_show_usage == 1 )) && _show_usage && return 0
    for arg_func in _save_github_json _delete_if_present _save_cabal2nix
    do
        (( $# == 0 )) && [[ $next_func == $arg_func ]] && {
            >&2 _show_usage_manage_override; return 1;
        }
    done
    _pushd_wd $working_dir
    [[ -n ${HOZ_DEBUG:-''} ]] && set -x
    trap 'set +x; popd > /dev/null' ERR INT TERM EXIT
    $next_func "$@"
    return 0
}

_pushd_wd() {
    local working_dir=$1
    [[ -d ${working_dir} ]] || mkdir -p ${working_dir}
    pushd ${working_dir} > /dev/null
}

_show_version() {
    echo $_HOZ_VERSION
}

_show_usage() {
    cat <<EOF
haskell-overridez - manage nix overrides for haskell packages
haskell-overridez fetch - fetch nix overrides from another git repo

version: $_HOZ_VERSION

EOF
    _show_usage_manage_override
    _show_usage_fetch
}

_show_usage_manage_override() {
    cat <<EOF
haskell-overridez

It adds a file to the nix subdirectory of a project containing either the
'prefetch' json or the nix expression output of cabal2nix describing the
target haskell package

These files are used by the functions of the accompanying nix-expr library to
create an override function that combines all the specified overrides.

Usage:
  haskell-overridez -i
    # {Re,}initialize the project: this adds nix/haskell-overridez.nix
    # if it not present or updates it if it's stale.
    #
    # nix/haskell-overridez.nix encapsulates the remote import
    # of the haskell-override nixpkgs functions, allowing the code
    # to import these functions to be as simple as
    # import ./nix/haskell-overridez.nix

  haskell-overridez [-g <username/project> [<revision>]]
    # Adds the override as a json file describing the git repo of the package

  haskell-overridez <any://uri/that/works/with/cabal2nix> [cabal2nix opts]
    # Adds the override as nix expression for a haskell package
    # Any additional args are passed to cabal2nix as flags

  haskell-overridez [-d <project-name>]
    # Delete the 'project-name' override file if present

  haskell-overridez [-o <target-dir> ] ...
    # Write output files under target-dir instead of the current working dir

  haskell-overridez -l
    # List all the saved overrides

  haskell-overridez -h
    # Show this help message

  HOZ_OPTS=<option-name-1>:<option-name-2> haskell-overridez ...
    # Apply one of the recognized cabal options when using the override
    #
    # The recognized cabal options are:
    #  doJailbreak:   ignore any incorrect dependency bounds
    #  dontCheck:     don't run the package's tests
    #  dontHaddock:   don't build the package documentation

Examples:

  haskell-overridez https://github.com/tathougies/beam --subpath beam-core
    # Install add the beam-core package

  haskell-overridez -g reflex-frp/reflex-dom-contrib
    # Install add the reflex-dom-contrib package

  HOZ_OPTS=doJailbreak:noCheck haskell-overridez -g reflex-frp/reflex-dom
    # Adds reflex-dom, ignoring bounds checks without running its tests

EOF
}

_delete_if_present() {
    local project=${1:-''}
    [[ -z $project ]] && { >&2 _show_usage_manage_override; return 1; }
    local github_file="$(pwd)/nix/git-json/${project}.json"
    local cabal2nix_file="$(pwd)/nix/nix-expr/${project}.nix"
    [[ -f ${github_file} ]] && rm ${github_file} && _echo "removed github json for $project"
    [[ -f ${cabal2nix_file} ]] && rm ${cabal2nix_file}  && _echo "removed nix-expr for $project"
    _maybe_remove_option $project
    return 0
}

_init_project() {
    local no_update=${1:-''}
    local out="$(pwd)/nix/haskell-overridez.nix"
    [[ -f $out ]] && [[ -n $no_update ]] && return 0;
    local archive_url="https://github.com/adetokunbo/haskell-overridez/archive/v${_HOZ_VERSION}.tar.gz"
    local the_hash=$(nix-prefetch-url --unpack ${archive_url})
    _ensure_parent_dir $out
    (cat <<EOF
let
  pkgs = import <nixpkgs> {};
  overridez = fetchTarball {
    url = "${archive_url}";
    sha256 = "${the_hash}";
  };
in
  import overridez { inherit pkgs; }
EOF
    ) > $out
}

_save_github_json() {
    local project=${1:-''}
    [[ -z $project ]] && { >&2 _show_usage_manage_override; return 1; }
    local revision=${2:-''}
    local url="https://github.com/${project}.git"

    _init_project "if necessary"

    local tmpdst=$(mktemp -d)
    trap "rm -fR $tmpdst" RETURN
    _save_using_nix_prefetch_git $tmpdst $url $revision
    local package=$(_name_from_default_nix $tmpdst)
    [[ -z "$package" ]] && package=$(_name_from_cabal $tmpdst)
    [[ -z "$package" ]] && {
        package="${project##*/}"
        _echo "*warning* no cabal or default.nix were present at the top-level of $url"
        _echo "*warning* defaulting to ${package} as the package name; you may want to change this"
    }

    local out="$(pwd)/nix/git-json/${package}.json"
    _ensure_parent_dir $out
    cp $tmpdst/github.json $out && {
        _echo "saved github json for ${url} to ${out}"
        _maybe_add_options $package
    }
}

_name_from_cabal() {
    local dst=${1:-''}
    [[ -z $dst ]] && return 1
    local glob="${dst}/*.cabal"
    ls ${glob} >> /dev/null 2>&1 && {
        cat ${glob} | sed -e '/Name:\s*/ s/\Name:[[:space:]]*\([^:space:]*\)/\1/ ; q '
    }
}

_name_from_default_nix() {
    local dst=${1:-''}
    [[ -z $dst ]] && return 1
    local target="${dst}/default.nix"
    [[ -f "$target" ]] && _nix_expr_field "pname" $target
}

_save_cabal2nix() {
    local pkg_uri=${1:-''}
    shift
    [[ -z $pkg_uri ]] && { >&2 _show_usage_manage_override; return 1; }
    _echo "cmd is cabal2nix $pkg_uri $@"
    [[ $pkg_uri =~ "cabal://" ]] && { _save_cabal2nix_cabal_uri $pkg_uri "$@"; return 0; }
    local nix_expr_tmp=$(mktemp -q) && {
        cabal2nix $pkg_uri "$@" > $nix_expr_tmp && {
            local project=$(_nix_expr_field "pname" "$nix_expr_tmp")
            local out="$(pwd)/nix/nix-expr/${project}.nix"
            _ensure_parent_dir $out
            _init_project "if necessary"
            cp $nix_expr_tmp $out
            _echo "saved nix-expr for ${project} to ${out}"
            _maybe_add_options $project
            rm -f $nix_expr_tmp
        }
    }
}

_nix_expr_field() {
    local name=${1:-''}
    local src=${2:-''}
    [[ -z $src ]] && return 1
    cat $src | grep "$name" | sed -e "s/.*$name = \"\(.*\)\".*/\1/"
}

_save_cabal2nix_cabal_uri() {
    local pkg_uri=${1:-''}
    shift
    [[ -z $HOZ_ALL_CABAL_HASHES:-'' ]] && return 1;
    local full_id=${pkg_uri##cabal://}

    # NOTE: search_path finds _a_ version if none is specified, but not the
    # __latest__ version.  This is to keep the implementation simple.
    local name=$(echo $full_id | sed -e 's/\(.*\)-[0123456789].*/\1/')
    local version=$(echo $full_id | sed -e 's/.*-\([0123456789].*\)/\1/')
    local search_path="/$name/$version/"
    [[ $version == $name ]] && { version=''; search_path="/$name/"; }

    _echo "searching for ${search_path} in the hackage db: ${HOZ_ALL_CABAL_HASHES}"
    in_tar=$(tar -tzvf $HOZ_ALL_CABAL_HASHES \
        | grep $search_path \
        | grep '\.cabal' \
        | sed -e 's/.*\(all-cabal-hashes.*cabal\)$/\1/' \
        | tail -n 1)
    [[ -z $in_tar ]] && { _echo "unknown cabal package: $pkg_uri"; return 1; }
    _echo "found: $in_tar for $pkg_uri"

    # Extract the cabal file and use that with cabal2nix
    tar -xvf $HOZ_ALL_CABAL_HASHES $in_tar >> /dev/null
    local unpacked_path="file://$(pwd)/${in_tar}"
    local unpacked_root=$(pwd)/${in_tar%%/*}
    export HOME=$unpacked_root

    [[ $version == '' ]] && {
        local layer1=${in_tar#*/}
        local layer2=${layer1#*/}
        _echo "*warning* no version specified for ${name}; using ${layer2}"
        _echo "*warning* ${layer2} may not be the most recent version"
        _echo "*warning* specify ${name} with a version if this not OK"
    }
    _save_cabal2nix $unpacked_path "$@"
    rm -fR $unpacked_root
}

_list_overrides() {
    [[ -d './nix/git-json' ]] && {
        echo "Git JSON"
        echo
        ls -1 ./nix/git-json
        echo
    }
    [[ -d './nix/nix-expr' ]] && {
        echo "Nix exprs"
        echo
        ls -1 ./nix/nix-expr
        echo
    }
    return 0
}

_ensure_parent_dir() {
    local path=$1
    mkdir -p $(dirname $path)
}

_maybe_add_options() {
    [[ -z ${HOZ_OPTS:-''} ]] && return 0
    local project=${1:-''}
    [[ -z $project ]] && return 0
    local hoz_opts_array=(${HOZ_OPTS//:/ })
    local opt_name
    for opt_name in ${hoz_opts_array[@]}
    do
        local used=0
        for known_opt in $_HOZ_KNOWN_OPTS
        do
            [[ $opt_name == $known_opt ]] && {
                _add_option $opt_name $project
                used=1
            }
        done
        (( $used == 0)) && _echo "ignored unrecognized option: $opt_name"
    done
    return 0
}

_add_option() {
    local opt_name=${1:-''}
    local project=${2:-''}
    [[ -z $project ]] && { >&2 _show_usage_manage_override; return 1; }
    local out="$(pwd)/nix/options/${opt_name}"
    _ensure_parent_dir $out
    [[ -f $out ]] || { echo $project >> $out ; return 0; }
    sed -i'' -e "/${project}\$/d" $out
    echo $project >> $out
    _echo "configured option $opt_name for $project"
}

_maybe_remove_option() {
    local project=${1:-''}
    [[ -z $project ]] && return 0
    for opt_name in $_HOZ_KNOWN_OPTS
    do
        local out="$(pwd)/nix/options/${opt_name}"
        [[ -f $out ]] && sed -i'' -e "/${project}$/d" $out
    done
}

_fetch_configs() {
    OPTIND=1
    local working_dir=$(pwd)
    local opt
    while getopts ":o:" opt;
    do
        case $opt in
            o)
                working_dir=$OPTARG
                ;;
            \?)
                >&2 echo "Invalid option: -$OPTARG"
                >&2 echo
                >&2 _show_usage_fetch
                return 1
                ;;
        esac
    done
    [[ -n ${HOZ_DEBUG:-''} ]] && set -x
    shift $((OPTIND-1))
    _pushd_wd $working_dir
    trap 'set +x; popd > /dev/null' INT TERM EXIT
    _fetch_to_cwd "$@"
}

_show_usage_fetch() {
    cat <<EOF
haskell-overridez fetch

Fetches configuration files from another git repository and saves them locally.

Usage:
  haskell-overridez fetch [<url://to/a/git/repo> [revision [expected-hash]]]
    # Fetches recognized haskell-overridez config from url://to/a/git/repo and stores
    # it in <nix/path/derived/from/url>. If revision is specified,
    # it is cloned at that revision. If expected-hash is provided, the command
    # exits if the clone repo does not have the required hash

  haskell-overridez fetch [-o <target-dir> ] ...
    # Copy the fetched configs to target-dir instead of the current working dir

Examples:

  haskell-overridez fetch https://github.com/adetokunbo/example-fetched-haskell-overridez
    # Fetches override config used in that repo
    # and saves it to nix/github.com/adetokunbo/example-fetched-haskell-overridez

  haskell-overridez fetch file:///my/private/git/project
    # Fetches override config if represent from the project
    # and saves it to nix/localhost/project

EOF
}

_fetch_to_cwd() {
    local target=${1:-''}
    local rev=${2:-''}
    local hash=${3:-''}
    [[ -z $target ]] && { >&2 _show_usage_fetch; return 1; }

    # figure out the save destination first; it fails if the target is invalid
    local out_subdir="nix/$(_out_subdir_from_target $target)"
    local tmpdst=$(mktemp -d)
    trap "rm -fR $tmpdst" RETURN

    _save_using_nix_prefetch_git $tmpdst $target $rev $hash
    _has_hoz_configs $tmpdst || return 1
    _echo "saving configs from $target to $out_subdir"
    _sync_hoz_configs $tmpdst $out_subdir
}

_out_subdir_from_target() {
    local target=${1:-''}
    [[ -z $target ]] && { >&2 _show_usage_fetch; return 1; }
    local suffix=${target#*://}
    local prefix=${target%://*}
    [[ ${target} == ${prefix} ]] && {
        _echo "${target} is not a valid url"
        >&2 _show_usage_fetch
        return 1
    }

    # for file:/// urls, use "localhost/<basename of git dir>"
    [[ $prefix == "file" ]] && echo "localhost/${suffix##*/}" && return 0

    # for other urls use the whole suffix, including the hostname
    echo $suffix
}

_save_using_nix_prefetch_git() {
    local tmpdst=${1:-''}
    local target=${2:-''}
    local rev=${3:-''}
    local hash=${4:-''}
    [[ -z $target ]] && { >&2 _show_usage_fetch; return 1; }

    # if the revision and hash are known, use the --builder flag with
    # nix-prefetch-git to download the repo to a tmp output directory
    [[ -n $hash ]] && {
        nix-prefetch-git --quiet --builder --out $tmpdst $target $rev $hash
        return 0
    }

    # otherwise use nix-prefetch-git to find the rev and hash then recurse
    # this is necessary because the builder flag requires the rev and hash
    local tmp_json=$(mktemp -q)
    nix-prefetch-git $target $rev > $tmp_json
    [[ -z $rev ]] && rev=$(_json_field "rev" $tmp_json)
    hash=$(_json_field "sha256" $tmp_json)
    [[ -z $rev ]] || [[ -z $hash ]] && {
        _echo "fetch failed: 'sha256' or 'rev' are either not given or found in:"
        >&2 cat $tmp_json
    }
    cat $tmp_json > "$tmpdst/github.json"
    _save_using_nix_prefetch_git $tmpdst $target $rev $hash
}

_json_field() {
    local name=${1:-''}
    local src=${2:-''}
    [[ -z $src ]] && return 1
    cat $src | grep "$name" | sed -e "s/.*\"$name\": \"\(.*\)\".*/\1/"
}

_has_hoz_configs() {
    local src=${1:-''}
    [[ -z $src ]] && return 1
    local hoz_globs=('nix/nix-expr/*.nix' 'nix/git-json/*.json')
    for known_opt in $_HOZ_KNOWN_OPTS
    do
        hoz_globs+=("nix/options/$known_opt")
    done
    for glob in "${hoz_globs[@]}"
    do
        _files_exist "$src/$glob" && return 0
    done

    _echo "bad fetch: could not find expected config files"
    return 1
}

_files_exist() {
    local glob=${1:-''}
    [[ -z $glob ]] && return 1;
    $(ls $glob >> /dev/null 2>&1)
}

_sync_hoz_configs() {
    local src=${1:-''}
    local dst=${2:-''}
    [[ -z $dst ]] && return 1
    _copy_if_present "$src/nix/nix-expr/*.nix" "$dst/nix-expr"
    _copy_if_present "$src/nix/git-json/*.json" "$dst/git-json"
    for known_opt in $_HOZ_KNOWN_OPTS
    do
        _copy_if_present "$src/nix/options/$known_opt" "$dst/options"
    done
}

_copy_if_present()   {
    local glob=${1:-''}
    local dst=${2:-''}
    [[ -z $dst ]] && return 1
    _files_exist $glob || return 0
    mkdir -p $dst && cp -v $glob $dst
}

_echo() {
  >&2 echo "haskell-overridez: $@"
}

haskell-overridez "$@"
